# Tips on troubleshooting failing tests



- When a test fails it'll create a dump in the test execution's folder, in a new *FailureDumps* folder. This will contain the Orchard application's folder (including logs), browser logs (i.e. the console output), a screenshot (Windows Photo Viewer won't be able to open it though, use something else like the Windows 10 Photos app), and the HTML output. If accessibility was checked and asserting it failed then an accessibility report will be included too. Together with the test output this should help you pinpoint where the issue is even if the test was run in the CI environment and you can't reproduce it locally.
- Run tests with the debugger attached to stop where the test fails. This way you can take a good look at what's in the driven browser window so you can examine the web page. Alternatively, if you want to debug the web app then you can run the test without debugging and attach the debugger to the *dotnet.exe* process running the app.
- If text form fields aren't always actually filled during the test then the recommended standard is to do the `Click()` - `Clear()` - `SendKeys()` pattern instead of just `SendKeys()`. Our `ClickAndFillInWith()` will do all of this.
- UI tests are not exact and a lot of things can randomly break. A typical issue is Selenium not finding elements when they're supposedly there. The foremost reason of this is that it attempted to access it before the given element was ready (like after a page load).
  - Atata's `Get()` includes retry logic specifically this. If some slow operation is still failing then just increase its timeout: It's better to have randomly slower tests and hackish solutions than to have randomly failing tests (which should be avoided at all costs because it'll make the whole test suite unreliable).
  - Be aware that if a page contains e.g. an element with the ID "Email", then you navigate away and the next page contains an element with the ID "Email" as well then a command will match it on the first page too, without waiting for the navigation to finish, even if you have a command to navigate away before that. So in such cases be sure to somehow execute a match that will indicate the navigation being done (like an element unique to the first page `Missing()` or `Get()`-ting a new one).
  - While tempting, don't use `Thread.Sleep()` to overcome a randomly failing condition! Use the above detailed mechanisms to do actions based on UI elements' presence.
- If you can't get a link or button click working for some random reason but it's one that initiates a page leave then use `ClickSafelyUntilPageLeave()`.
- An aborted test can leave processes open (a failed test should clean up after itself nevertheless). Look for *dotnet.exe* and *chromedriver.exe* processes (and also for *geckodriver.exe*, *IEDriverServer.exe* and *msedgedriver.exe* if you use other browsers) with [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) and kill them. You can also use the included *KillLeftoverProcesses.bat** script to kill these (optionally install the [Command Task Runner](https://marketplace.visualstudio.com/items?itemName=MadsKristensen.CommandTaskRunner) Visual Studio Extension so you can run this script from Task Runner Explorer directly). If you see build warnings or errors with files being locked then most possibly a *dotnet.exe* process is locking them (or an IIS Express one if you have run the app from VS too). If you get an `IOException` with the message along the lines of "Starting the Orchard Core application via dotnet.exe failed with the following output: Unhandled exception. System.IO.IOException: Failed to bind to address https://127.0.0.1:5122: address already in use." then that's also because there's a leftover *dotnet.exe* is using a port.
- A difference in the results of a normal and headless execution is almost always because of different window sizes since headless mode uses small browser windows by default (if this is the case, you should see the issue right away from the failure dump's screenshot). To overcome this, always set the browser window's size explicitly with `SetBrowserSize()` (which is a good practice anyway, because otherwise in normal mode it won't be reliable either). Note that if you switch windows/tabs during the test you may need to set the browser size again.
