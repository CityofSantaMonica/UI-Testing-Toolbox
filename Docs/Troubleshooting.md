# Tips on troubleshooting failing tests



- When a test fails it'll create a dump with the Orchard application's folder (including logs), browser logs (i.e. the console output), a screenshot (Windows Photo Viewer won't be able to open it though, use something else like the Windows 10 Photos app), the HTML output. If accessibility was checked and asserting it failed then an accessibility report will be included too. Together with the test output this should help you pinpoint where the issue is even if the test was run in the CI environment and you can't reproduce it locally.
- Run tests with the debugger attached to stop where the test fails. This way you can take a good look at what's in the driven browser window so you can examine the web page. Alternatively, if you want to debug the web app then you can run the test without debugging and attach the debugger to the _dotnet.exe_ process running the app.
- If text form fields aren't always actually filled during the test then the recommended standard is to do the `Click()` - `Clear()` - `SendKeys()` pattern instead of just `SendKeys()`. Our `ClickAndFillInWith()` will do all of this.
- UI tests are not exact and a lot of things can randomly break. A typical issue is Selenium not finding elements when they're supposedly there. The foremost reason of this is that it attempted before the given element was ready (like after a page load).
  - Atata's `Get()` includes retry logic specifically this. If some slow operation is still failing then just increase its timeout: It's better to have randomly slower tests and hackish solutions than to have randomly failing tests (which should be avoided at all costs because it'll make the whole test suite unreliable).
  - Be aware that if a page contains e.g. an element with the ID "Email", then you navigate away and the next page contains an element with the ID "Email" as well then a command will match it on the first page too, without waiting for the navigation to finish, even if you have a command to navigate away before that. So in such cases be sure to somehow execute a match that will indicate the navigation being done (like an element unique to the first page `Missing()` or `Get()`-ting a new one).
  - While tempting, don't use `Thread.Sleep()` to overcome a randomly failing condition! Use the above detailed mechanisms to do actions based on UI elements' presence.
- If you can't get a link or button click working for some random reason but it's one that initiates a page leave then use `ClickSafelyUntilPageLeave()`.
- An aborted test can leave processes open (a failed test should clean up after itself nevertheless). Look for _dotnet.exe_ and _chromedriver.exe_ processes (and also for _geckodriver.exe_, _IEDriverServer.exe_ and _msedgedriver.exe_ if you use other browsers) with [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) and kill them. You can also use the included _KillLeftoverProcesses.bat_ script to kill these. If you see build warnings or errors with files being locked then most possibly a _dotnet.exe_ process is locking them (or an IIS Express one if you have run the app from VS too). If you get an `IOException` with the message along the lines of "Starting the Orchard Core application via dotnet.exe failed with the following output: Unhandled exception. System.IO.IOException: Failed to bind to address https://127.0.0.1:5122: address already in use." then that's also because there's a leftover _dotnet.exe_ is using a port.
